"""
noseperf.plugin
~~~~~~~~~~~~~~~

:copyright: (c) 2012 DISQUS
:license: Apache License 2.0, see LICENSE for more details.
"""
from __future__ import absolute_import

from datetime import datetime
import json
import logging
import os
import sys
import time

from nose.plugins.base import Plugin

from noseperf.testcases import PerformanceTest
from noseperf.util import PatchContext
from noseperf.wrappers import patch_cursor, PerformanceCacheWrapper, PerformanceRedisWrapper, \
  RedisPipelineHook


class PerformancePlugin(Plugin):
    """
    Nose performance plugin.

    This plugin is used with the DisqusPerformanceTest class. This plugin will
    profile each test and dump all of the raw data into a json file. If the
    `--performance-html` flag is passed then an html report of the data is generated.

    For this test to be super helpful passing in a fixture set generated by the
    `loaddata` command. Then run the tests as follows:

    ./runtests.py /tests/performance/ --with-performance --performance-html --fixture=path/to/fixture/file.
    """
    score = -sys.maxint - 1  # Should be the absolute last thing ever to run since it transparently monitors the code.
    enabled = False
    logger = logging.getLogger(__name__)

    def _get_name_from_test(self, test):
        test_method_name = test._testMethodName

        # We need to determine the *actual* test path (as thats what nose gives us in wantMethod)
        # for example, maybe a test was imported in foo.bar.tests, but originated as foo.bar.something.MyTest
        # in this case, we'd need to identify that its *actually* foo.bar.something.MyTest to record the
        # proper coverage
        test_ = getattr(sys.modules[test.__module__], test.__class__.__name__)

        test_name = '%s:%s.%s' % (test_.__module__, test_.__name__,
                                                     test_method_name)

        return test_name

    def options(self, parser, env):
        parser.add_option("--with-performance", dest="enable_performance",
            default=False, action="store_true",
            help="Enable the performance plugin.")

        parser.add_option("--performance-json-file", dest="performance_file",
            default="performance.json", metavar="FILE",
            help="Save Results in file. Defaults to performance.json")

        parser.add_option("--performance-revision", dest="performance_revision",
            default=None, help="Revision name to identify this build")

        parser.add_option("--performance-schema", dest="performance_schema",
            default=None, help="Schema to identify this build with")

    def configure(self, options, conf):
        if not options.enable_performance:
            return

        self.enabled = True
        self.json_file = options.performance_file
        self.revision = options.performance_revision
        self.schema = options.performance_schema

    def wantClass(self, cls):
        """
        Only profile performance tests.
        """
        return issubclass(cls, PerformanceTest)

    def begin(self):
        self.start_time = datetime.now()
        self.tests = []
        self.context_stack = []

    def patch_interfaces(self):
        self._sql_data = []
        self._cache_data = []
        self._redis_data = []

        try:
            from django.conf import settings
            if not settings.configured:
                raise ImportError
        except ImportError:
            pass
        else:
            self.patch_django_interfaces()

        try:
            __import__('redis')
        except ImportError:
            pass
        else:
            self.add_context(PatchContext('redis.client.StrictRedis.execute_command', PerformanceRedisWrapper(self._redis_data)))
            self.add_context(PatchContext('redis.client.BasePipeline.execute', RedisPipelineHook(self._redis_data)))

    def patch_django_interfaces(self):
        import django
        from django.conf import settings

        self.add_context(PatchContext('django.db.backends.BaseDatabaseWrapper.cursor', patch_cursor(self._sql_data)))

        cache_backends = set()
        if django.VERSION < (1, 3):
            for backend in ('locmem', 'filebased', 'memcache', 'dummy'):
                path = 'django.core.cache.backends.%s.CacheClass' % backend
                cache_backends.add(path)

            backend = settings.CACHE_BACKEND.split(':', 1)[0]
            if '.' not in backend:
                backend = 'django.core.cache.%s' % backend
            path = '%s.CacheClass' % backend
            cache_backends.add(path)

        else:
            for backend, cls in (('locmem', 'LocMemCache'), ('filebased', 'FileBasedCache'),
                                 ('memcache', 'BaseMemcachedCache'), ('dummy', 'DummyCache')):
                for cmd in ('get', 'set', 'add', 'delete', 'get_many'):
                    path = 'django.core.cache.backends.%s.%s' % (backend, cls)
                    cache_backends.add(path)

            for cache_config in settings.CACHES.itervalues():
                cache_backends.add(cache_config['BACKEND'])

        for path in cache_backends:
            for cmd in ('get', 'set', 'add', 'delete', 'get_many'):
                self.add_context(PatchContext('%s.%s' % (path, cmd), PerformanceCacheWrapper(self._cache_data, cmd)))

    def add_context(self, ctx):
        ctx.__enter__()
        self.context_stack.append(ctx)

    def clear_context(self):
        while self.context_stack:
            self.context_stack.pop().__exit__(None, None, None)

    def beforeTest(self, test):
        self.patch_interfaces()

    def startTest(self, test):
        self.start = time.time()

    def stopTest(self, test):
        self.end = time.time()

    def afterTest(self, test):
        self.clear_context()

        if not hasattr(self, 'end'):
            return

        interfaces = {}

        data = {
            'id': test.test.id(),
            'doc': test.test._testMethodDoc,
            'duration': self.end - self.start,
            'interfaces': interfaces,
        }

        interfaces.update({
            'sql': self._sql_data,
            'cache': self._cache_data,
            'redis': self._redis_data,
        })

        self.tests.append(data)

    def report(self, stream):
        base_dir = os.getcwd() + '/test_results/'
        if not os.path.exists(base_dir):
            os.makedirs(base_dir)

        # Dump the raw data to json
        with open(base_dir + self.json_file, "w+") as f:
            data = {
                'time': self.start_time.isoformat(),
                'tests': self.tests,
                'revision': self.revision,
                'schema': self.schema,
            }
            json.dump(data, f, indent=4)
