"""
noseperf.plugin
~~~~~~~~~~~~~~~

:copyright: (c) 2012 DISQUS
:license: Apache License 2.0, see LICENSE for more details.
"""
from __future__ import absolute_import

from datetime import datetime
import json
import logging
import os
import sys
import time

from nose.plugins.base import Plugin

from noseperf.testcases import PerformanceTest
from noseperf.util import PatchContext
from noseperf.wrappers import patch_cursor, PerformanceCacheWrapper, PerformanceRedisWrapper


class PerformancePlugin(Plugin):
    """
    Nose performance plugin.

    This plugin is used with the DisqusPerformanceTest class. This plugin will
    profile each test and dump all of the raw data into a json file. If the
    `--performance-html` flag is passed then an html report of the data is generated.

    For this test to be super helpful passing in a fixture set generated by the
    `loaddata` command. Then run the tests as follows:

    ./runtests.py /tests/performance/ --with-performance --performance-html --fixture=path/to/fixture/file.
    """
    score = -sys.maxint - 1  # Should be the absolute last thing ever to run since it transparently monitors the code.
    enabled = False
    logger = logging.getLogger(__name__)

    def options(self, parser, env):
        parser.add_option("--with-performance", dest="enable_performance",
                default=False, action="store_true",
                help="Enable the performance plugin.")

        parser.add_option("--performance-json-file", dest="performance_file",
                         default="performance.json", metavar="FILE",
                         help="Save Results in file. Defaults to performance.json")

        parser.add_option("--performance-html", dest="performance_html",
                        default=False, action="store_true",
                        help="Create an HTML Report")

    def configure(self, options, conf):
        if options.enable_performance:
            self.enabled = True
        else:
            return

        self.json_file = options.performance_file
        self.enable_html = options.performance_html

    def wantClass(self, cls):
        """
        Only profile performance tests.
        """
        return issubclass(cls, PerformanceTest)

    def begin(self):
        self.start_time = datetime.now()
        self.tests = []
        self.context_stack = []

    def beforeTest(self, test):
        # Patch everything needed to get data.

        self._sql_data = []
        self.add_context(PatchContext('django.db.backends.BaseDatabaseWrapper.cursor', patch_cursor(self._sql_data)))

        self._cache_data = []
        self.add_context(PatchContext('django.core.cache.backends.locmem.CacheClass.get', PerformanceCacheWrapper(self._cache_data, 'get')))
        self.add_context(PatchContext('django.core.cache.backends.locmem.CacheClass.set', PerformanceCacheWrapper(self._cache_data, 'set')))
        self.add_context(PatchContext('django.core.cache.backends.locmem.CacheClass.add', PerformanceCacheWrapper(self._cache_data, 'add')))
        self.add_context(PatchContext('django.core.cache.backends.locmem.CacheClass.delete', PerformanceCacheWrapper(self._cache_data, 'delete')))
        self.add_context(PatchContext('django.core.cache.backends.locmem.CacheClass.get_many', PerformanceCacheWrapper(self._cache_data, 'get_many')))

        self._redis_data = []
        self.add_context(PatchContext('redis.client.StrictRedis.execute_command', PerformanceRedisWrapper(self._redis_data)))

        self._pipeline_redis_data = []
        self.add_context(PatchContext('redis.client.BasePipeline.execute_command', PerformanceRedisWrapper(self._pipeline_redis_data)))

    def startTest(self, test):
        self.start = time.time()

    def add_context(self, ctx):
        ctx.__enter__()
        self.context_stack.append(ctx)

    def clear_context(self):
        while self.context_stack:
            self.context_stack.pop().__exit__(None, None, None)

    def stopTest(self, test):
        self.end = time.time()

    def afterTest(self, test):
        # Save a dict of data for this test.
        self.clear_context()

        data = {
            'id': test.test.id(),
            'doc': test.test._testMethodDoc,
            'duration': self.end - self.start,
        }

        data['sql'] = self._sql_data
        data['cache'] = self._cache_data
        data['redis'] = self._redis_data
        data['pipelined_redis'] = self._pipeline_redis_data
        data['duration'] = self.end - self.start
        meth = getattr(test.test, test.test._testMethodName)
        data['api_data'] = getattr(meth, 'api_data', {})

        self.tests.append(data)

    def report(self, stream):
        base_dir = os.getcwd() + '/test_results/'

        # Dump the raw data to json
        with open(base_dir + self.json_file, "w+") as f:
            data = {}
            data["time"] = self.start_time.isoformat()
            data["tests"] = self.tests
            json.dump(data, f, indent=4)
